contents
1.1 the elements of programming 1.1.1 expressions 1.1.2 naming and the environment 1.1.3 evaluating combinations 1.1.4 compound procedures 1.1.5 the substitution model for procedure application 1.1.6 conditional expressions and predicates 1.1.7 example square roots by newton's method 1.1.8 procedures as black box abstractions 1.2 procedures and the processes they generate 1.2.1 linear recursion and iteration 1.2.2 tree recursion 1.2.3 orders of growth 1.2.4 exponentiation 1.2.5 greatest common divisors 1.2.6 example testing for primality 1.3 formulating abstractions with higher order procedures 1.3.1 procedures as arguments 1.3.2 constructing procedures using lambda 1.3.3 procedures as general methods 1.3.4 procedures as returned values
2.1 introduction to data abstraction 2.1.1 example arithmetic operations for rational numbers 2.1.2 abstraction barriers 2.1.3 what is meant by data
two point one point four extended exercise interval arithmetic two point two hierarchical data and the closure property two point two point one representing sequences two point two point two hierarchical structures two point two point three sequences as conventional interfaces two point two point four example a picture language two point three symbolic data two point three point one quotation two point three point two example symbolic differentiation two point three point three example representing sets two point three point four example huffman encoding trees two point four multiple representations for abstract data two point four point one representations for complex numbers two point four point two tagged data two point four point three data directed programming and additivity two point five systems with generic operations two point five point one generic arithmetic operations two point five point two combining data of different types two point five point three example symbolic algebra
3.1 assignment and local state 3.1.1 local state variables 3.1.2 the benefits of introducing assignment 3.1.3 the costs of introducing assignment 3.2 the environment model of evaluation 3.2.1 the rules for evaluation 3.2.2 applying simple procedures 3.2.3 frames as the repository of local state 3.2.4 internal definitions 3.3 modeling with mutable data 3.3.1 mutable list structure 3.3.2 representing queues 3.3.3 representing tables 3.3.4 a simulator for digital circuits 3.3.5 propagation of constraints 3.4 concurrency time is of the essence 3.4.1 the nature of time in concurrent systems 3.4.2 mechanisms for controlling concurrency 3.5 streams 3.5.1 streams are delayed lists 3.5.2 infinite streams 3.5.3 exploiting the stream paradigm 3.5.4 streams and delayed evaluation 3.5.5 modularity of functional programs and modularity of objects
4.1 the metacircular evaluator 4.1.1 the core of the evaluator 4.1.2 representing expressions 4.1.3 evaluator data structures 4.1.4 running the evaluator as a program 4.1.5 data as programs 4.1.6 internal definitions 4.1.7 separating syntactic analysis from execution 4.2 variations on a scheme lazy evaluation 4.2.1 normal order and applicative order 4.2.2 an interpreter with lazy evaluation 4.2.3 streams as lazy lists 4.3 variations on a scheme nondeterministic computing 4.3.1 amb and search 4.3.2 examples of nondeterministic programs 4.3.3 implementing the amb evaluator 4.4 logic programming 4.4.1 deductive information retrieval 4.4.2 how the query system works 4.4.3 is logic programming mathematical logic
4.4.4 implementing the query system
5.1 designing register machines 5.1.1 a language for describing register machines 5.1.2 abstraction in machine design 5.1.3 subroutines 5.1.4 using a stack to implement recursion 5.1.5 instruction summary 5.2 a register machine simulator 5.2.1 the machine model 5.2.2 the assembler 5.2.3 generating execution procedures for instructions 5.2.4 monitoring machine performance 5.3 storage allocation and garbage collection 5.3.1 memory as vectors 5.3.2 maintaining the illusion of infinite memory 5.4 the explicit control evaluator 5.4.1 the core of the explicit control evaluator 5.4.2 sequence evaluation and tail recursion 5.4.3 conditionals assignments and definitions 5.4.4 running the evaluator 5.5 compilation 5.5.1 structure of the compiler 5.5.2 compiling expressions 5.5.3 compiling combinations 5.5.4 combining instruction sequences 5.5.5 an example of compiled code 5.5.6 lexical addressing 5.5.7 interfacing compiled code to the evaluator
