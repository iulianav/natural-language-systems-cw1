preface to the first edition
the structure and interpretation of computer programs is the entry level subject in computer science at the massachusetts institute of technology
it is required of all students at mit who major in electrical engineering or in computer science as one fourth of the common core curriculum which also includes two subjects on circuits and linear systems and a subject on the design of digital systems
we have been involved in the development of this subject since 1978 and we have taught this material in its present form since the fall of 1980 to between six hundred and seven hundred students each year
most of these students have had little or no prior formal training in computation although many have played with computers a bit and a few have had extensive programming or hardware design experience
our design of this introductory computer science subject reflects two major concerns
first we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology
thus programs must be written for people to read and only incidentally for machines to execute
second we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming language constructs nor clever algorithms for computing particular functions efficiently nor even the mathematical analysis of algorithms and the foundations of computing but rather the techniques used to control the intellectual complexity of large software systems
our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming
they should have command of the major techniques for controlling complexity in a large system
they should be capable of reading a fifty page long program if it is written in an exemplary style
they should know what not to read and what they need not understand at any moment
they should feel secure about modifying a program retaining the spirit and style of the original author
these skills are by no means unique to computer programming
the techniques we teach and draw upon are common to all of engineering design
we control complexity by building abstractions that hide details when appropriate
we control complexity by establishing conventional interfaces that enable us to construct systems by combining standard well understood pieces in a mix and match way
we control complexity by establishing new languages for describing a design each of which emphasizes particular aspects of the design and deemphasizes others
underlying our approach to this subject is our conviction that computer science is not a science and that its significance has little to do with computers
the computer revolution is a revolution in the way we think and in the way we express what we think
the essence of this change is the emergence of what might best be called procedural epistemology the study of the structure of knowledge from an imperative point of view as opposed to the more declarative point of view taken by classical mathematical subjects
mathematics provides a framework for dealing precisely with notions of what is . computation provides a framework for dealing precisely with notions of how to
in teaching our material we use a dialect of the programming language lisp
we never formally teach the language because we do n't have to
we just use it and students pick it up in a few days
this is one great advantage of lisp like languages they have very few ways of forming compound expressions and almost no syntactic structure
all of the formal properties can be covered in an hour like the rules of chess
after a short time we forget about syntactic details of the language and get on with the real issues figuring out what we want to compute how we will decompose problems into manageable parts and how we will work on the parts
another advantage of lisp is that it supports more of the large scale strategies for modular decomposition of programs than any other language we know
we can make procedural and data abstractions we can use higher order functions to capture common patterns of usage we can model local state using assignment and data mutation we can link parts of a program with streams and delayed evaluation and we can easily implement embedded languages
all of this is embedded in an interactive environment with excellent support for incremental program design construction testing and debugging
we thank all the generations of lisp wizards starting with john mccarthy who have fashioned a fine tool of unprecedented power and elegance
scheme the dialect of lisp that we use is an attempt to bring together the power and elegance of lisp and algol
from lisp we take the metalinguistic power that derives from the simple syntax the uniform representation of programs as data objects and the garbage collected heap allocated data
from algol we take lexical scoping and block structure which are gifts from the pioneers of programming language design who were on the algol committee
we wish to cite john reynolds and peter landin for their insights into the relationship of church's lambda calculus to the structure of programming languages
we also recognize our debt to the mathematicians who scouted out this territory decades before computers appeared on the scene
these pioneers include alonzo church barkley rosser stephen kleene and haskell curry
