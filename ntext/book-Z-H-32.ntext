in order to gain a good understanding of the design of register machines we must test the machines we design to see if they perform as expected
one way to test a design is to hand simulate the operation of the controller as in exercise five point five
but this is extremely tedious for all but the simplest machines
in this section we construct a simulator for machines described in the register machine language
the simulator is a scheme program with four interface procedures
the first uses a description of a register machine to construct a model of the machine and the other three allow us to simulate the machine by manipulating the model
constructs and returns a model of the machine with the given registers operations and controller
stores a value in a simulated register in the given machine
returns the contents of a simulated register in the given machine
simulates the execution of the given machine starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence
as an example of how these procedures are used we can define gcd machine to be a model of the gcd machine of section five point one point one as follows
the first argument to make machine is a list of register names
the next argument is a table that pairs each operation name with a scheme procedure that implements the operation
the last argument specifies the controller as a list of labels and machine instructions as in section five point one
to compute gcds with this machine we set the input registers start the machine and examine the result when the simulation terminates
this computation will run much more slowly than a gcd procedure written in scheme because we will simulate low level machine instructions such as assign by much more complex operations
use the simulator to test the machines you designed in exercise five point four
the machine model generated by make machine is represented as a procedure with local state using the message passing techniques developed in chapter three
to build this model make machine begins by calling the procedure make new machine to construct the parts of the machine model that are common to all register machines
this basic machine model constructed by make new machine is essentially a container for some registers and a stack together with an execution mechanism that processes the controller instructions one by one
make machine then extends this basic model to include the registers operations and controller of the particular machine being defined
first it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine
then it uses an assembler to transform the controller list into instructions for the new machine and installs these as the machine's instruction sequence
make machine returns as its value the modified machine model
we will represent a register as a procedure with local state as in chapter three
the procedure make register creates a register that holds a value that can be accessed or changed
the following procedures are used to access registers
we can also represent a stack as a procedure with local state
the procedure make stack creates a stack whose local state consists of a list of the items on the stack
a stack accepts requests to push an item onto the stack to pop the top item off the stack and return it and to initialize the stack to empty
the following procedures are used to access stacks
the make new machine procedure shown in figure five point thirteen constructs an object whose local state consists of a stack an initially empty instruction sequence a list of operations that initially contains an operation to initialize the stack and a register table that initially contains two registers named flag and pc
the internal procedure allocate register adds new entries to the register table and the internal procedure lookup register looks up registers in the table
the flag register is used to control branching in the simulated machine
test instructions set the contents of flag to the result of the test
branch instructions decide whether or not to branch by examining the contents of flag
the pc register determines the sequencing of instructions as the machine runs
this sequencing is implemented by the internal procedure execute
in the simulation model each machine instruction is a data structure that includes a procedure of no arguments called the instruction execution procedure such that calling this procedure simulates executing the instruction
as the simulation runs pc points to the place in the instruction sequence beginning with the next instruction to be executed
execute gets that instruction executes it by calling the instruction execution procedure and repeats this cycle until there are no more instructions to execute
as part of its operation each instruction execution procedure modifies pc to indicate the next instruction to be executed
branch and goto instructions change pc to point to the new destination
all other instructions simply advance pc making it point to the next instruction in the sequence
observe that each call to execute calls execute again but this does not produce an infinite loop because running the instruction execution procedure changes the contents of pc
make new machine returns a dispatch procedure that implements message passing access to the internal state
notice that starting the machine is accomplished by setting pc to the beginning of the instruction sequence and calling execute
for convenience we provide an alternate procedural interface to a machine's start operation as well as procedures to set and examine register contents as specified at the beginning of section five point two
these procedures use the following to look up the register with a given name in a given machine
the assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions each with its execution procedure
overall the assembler is much like the evaluators we studied in chapter four there is an input language and we must perform an appropriate action for each type of expression in the language
the technique of producing an execution procedure for each instruction is just what we used in section four point one point seven to speed up the evaluator by separating analysis from runtime execution
as we saw in chapter four much useful analysis of scheme expressions could be performed without knowing the actual values of variables
here analogously much useful analysis of register machine language expressions can be performed without knowing the actual contents of machine registers
for example we can replace references to registers by pointers to the register objects and we can replace references to labels by pointers to the place in the instruction sequence that the label designates
before it can generate the instruction execution procedures the assembler must know what all the labels refer to so it begins by scanning the controller text to separate the labels from the instructions
as it scans the text it constructs both a list of instructions and a table that associates each label with a pointer into that list
then the assembler augments the instruction list by inserting the execution procedure for each instruction
the assemble procedure is the main entry to the assembler
it takes the controller text and the machine model as arguments and returns the instruction sequence to be stored in the model
assemble calls extract labels to build the initial instruction list and label table from the supplied controller text
the second argument to extract labels is a procedure to be called to process these results this procedure uses update insts to generate the instruction execution procedures and insert them into the instruction list and returns the modified list
extract labels takes as arguments a list text and a receive procedure
receive will be called with two values ( one ) a list insts of instruction data structures each containing an instruction from text and ( two ) a table called labels which associates each label from text with the position in the list insts that the label designates
extract labels works by sequentially scanning the elements of the text and accumulating the insts and the labels
if an element is a symbol an appropriate entry is added to the labels table
otherwise the element is accumulated onto the insts list
update insts modifies the instruction list which initially contains only the text of the instructions to include the corresponding execution procedures
the machine instruction data structure simply pairs the instruction text with the corresponding execution procedure
the execution procedure is not yet available when extract labels constructs the instruction and is inserted later by update insts
the instruction text is not used by our simulator but it is handy to keep around for debugging
elements of the label table are pairs
entries will be looked up in the table with
the following register machine code is ambiguous because the label here is defined more than once
with the simulator as written what will the contents of register a be when control reaches there
modify the extract labels procedure so that the assembler will signal an error if the same label name is used to indicate two different locations
the assembler calls make execution procedure to generate the execution procedure for an instruction
like the analyze procedure in the evaluator of section four point one point seven this dispatches on the type of instruction to generate the appropriate execution procedure
for each type of instruction in the register machine language there is a generator that builds an appropriate execution procedure
the details of these procedures determine both the syntax and meaning of the individual instructions in the register machine language
we use data abstraction to isolate the detailed syntax of register machine expressions from the general execution mechanism as we did for evaluators in section four point one point two by using syntax procedures to extract and classify the parts of an instruction
the make assign procedure handles assign instructions
make assign extracts the target register name and the value expression
from the assign instruction using the selectors
the register name is looked up with get register to produce the target register object
the value expression is passed to make operation exp if the value is the result of an operation and to make primitive exp otherwise
these procedures parse the value expression and produce an execution procedure for the value
this is a procedure of no arguments called value proc which will be evaluated during the simulation to produce the actual value to be assigned to the register
notice that the work of looking up the register name and parsing the value expression is performed just once at assembly time not every time the instruction is simulated
this saving of work is the reason we use execution procedures and corresponds directly to the saving in work we obtained by separating program analysis from execution in the evaluator of section four point one point seven
the result returned by make assign is the execution procedure for the assign instruction
when this procedure is called it sets the contents of the target register to the result obtained by executing value proc
then it advances the pc to the next instruction by running the procedure
advance pc is the normal termination for all instructions except branch and goto
make test handles test instructions in a similar way
it extracts the expression that specifies the condition to be tested and generates an execution procedure for it
at simulation time the procedure for the condition is called the result is assigned to the flag register and the pc is advanced
the execution procedure for a branch instruction checks the contents of the flag register and either sets the contents of the pc to the branch destination or else just advances the pc
notice that the indicated destination in a branch instruction must be a label and the make branch procedure enforces this
notice also that the label is looked up at assembly time not each time the branch instruction is simulated
a goto instruction is similar to a branch except that the destination may be specified either as a label or as a register and there is no condition to check the pc is always set to the new destination
the stack instructions save and restore simply use the stack with the designated register and advance the pc
the final instruction type handled by make perform generates an execution procedure for the action to be performed
at simulation time the action procedure is executed and the pc advanced
the value of a reg label or const expression may be needed for assignment to a register or for input to an operation
the following procedure generates execution procedures to produce values for these expressions during the simulation
the syntax of reg label and const expressions is determined by
assign perform and test instructions may include the application of a machine operation to some operands
the following procedure produces an execution procedure for an operation expression a list containing the operation and operand expressions from the instruction
the syntax of operation expressions is determined by
observe that the treatment of operation expressions is very much like the treatment of procedure applications by the analyze application procedure in the evaluator of section four point one point seven in that we generate an execution procedure for each operand
at simulation time we call the operand procedures and apply the scheme procedure that simulates the operation to the resulting values
the simulation procedure is found by looking up the operation name in the operation table for the machine
the treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers
modify the expression processing procedures to enforce the condition that operations can be used only with registers and constants
design a new syntax for register machine instructions and modify the simulator to use your new syntax
can you implement your new syntax without changing any part of the simulator except the syntax procedures in this section
when we introduced save and restore in section five point one point four we did n't specify what would happen if you tried to restore a register that was not the last one saved as in the sequence
there are several reasonable possibilities for the meaning of restore
a
puts into y the last value saved on the stack regardless of what register that value came from
this is the way our simulator behaves
show how to take advantage of this behavior to eliminate one instruction from the fibonacci machine of section five point one point four
b
puts into y the last value saved on the stack but only if that value was saved from y otherwise it signals an error
modify the simulator to behave this way
you will have to change save to put the register name on the stack along with the value
c
puts into y the last value saved from y regardless of what other registers were saved after y and not restored
modify the simulator to behave this way
you will have to associate a separate stack with each register
you should make the initialize stack operation initialize all the register stacks
the simulator can be used to help determine the data paths required for implementing a machine with a given controller
extend the assembler to store the following information in the machine model
a list of all instructions with duplicates removed sorted by instruction type
a list of the registers used to hold entry points
a list of the registers that are save d or restore d
for each register a list of the sources from which it is assigned
extend the message passing interface to the machine to provide access to this new information
to test your analyzer define the fibonacci machine from figure five point twelve and examine the lists you constructed
modify the simulator so that it uses the controller sequence to determine what registers the machine has rather than requiring a list of registers as an argument to make machine
instead of pre allocating the registers in make machine you can allocate them one at a time when they are first seen during assembly of the instructions
simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine's performance
for example we can install in our simulation program a meter that measures the number of stack operations used in a computation
to do this we modify our simulated stack to keep track of the number of times registers are saved on the stack and the maximum depth reached by the stack and add a message to the stack's interface that prints the statistics as shown below
we also add an operation to the basic machine model to print the stack statistics by initializing the ops in make new machine to
here is the new version of make stack
exercises five point fifteen through five point nineteen describe other useful monitoring and debugging features that can be added to the register machine simulator
measure the number of pushes and the maximum stack depth required to compute n for various small values of n using the factorial machine shown in figure five point eleven
from your data determine formulas in terms of n for the total number of push operations and the maximum stack depth used in computing n for any n > one
note that each of these is a linear function of n and is thus determined by two constants
in order to get the statistics printed you will have to augment the factorial machine with instructions to initialize the stack and print the statistics
you may want to also modify the machine so that it repeatedly reads a value for n computes the factorial and prints the result so that you will not have to repeatedly invoke get register contents set register contents and start
add instruction counting to the register machine simulation
that is have the machine model keep track of the number of instructions executed
extend the machine model's interface to accept a new message that prints the value of the instruction count and resets the count to zero
augment the simulator to provide for instruction tracing
that is before each instruction is executed the simulator should print the text of the instruction
make the machine model accept trace on and trace off messages to turn tracing on and off
extend the instruction tracing of exercise five point sixteen so that before printing an instruction the simulator prints any labels that immediately precede that instruction in the controller sequence
be careful to do this in a way that does not interfere with instruction counting
you will have to make the simulator retain the necessary label information
modify the make register procedure of section five point two point one so that registers can be traced
registers should accept messages that turn tracing on and off
when a register is traced assigning a value to the register should print the name of the register the old contents of the register and the new contents being assigned
extend the interface to the machine model to permit you to turn tracing on and off for designated machine registers
alyssa p
hacker wants a breakpoint feature in the simulator to help her debug her machine designs
you have been hired to install this feature for her
she wants to be able to specify a place in the controller sequence where the simulator will stop and allow her to examine the state of the machine
you are to implement a procedure
that sets a breakpoint just before the nth instruction after the given label
for example
installs a breakpoint in gcd machine just before the assignment to register a
when the simulator reaches the breakpoint it should print the label and the offset of the breakpoint and stop executing instructions
alyssa can then use get register contents and set register contents to manipulate the state of the simulated machine
she should then be able to continue execution by saying
she should also be able to remove a specific breakpoint by means of
or to remove all breakpoints by means of
