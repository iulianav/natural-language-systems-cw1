chapter two dealt with compound data as a means for constructing computational objects that have several parts in order to model real world objects that have several aspects
in that chapter we introduced the discipline of data abstraction according to which data structures are specified in terms of constructors which create data objects and selectors which access the parts of compound data objects
but we now know that there is another aspect of data that chapter two did not address
the desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects as well as to construct and select from them
in order to model compound objects with changing state we will design data abstractions to include in addition to selectors and constructors operations called mutators which modify data objects
for instance modeling a banking system requires us to change account balances
thus a data structure for representing bank accounts might admit an operation
that changes the balance of the designated account to the designated new value
data objects for which mutators are defined are known as mutable data objects
chapter two introduced pairs as a general purpose glue for synthesizing compound data
we begin this section by defining basic mutators for pairs so that pairs can serve as building blocks for constructing mutable data objects
these mutators greatly enhance the representational power of pairs enabling us to build data structures other than the sequences and trees that we worked with in section two point two
we also present some examples of simulations in which complex systems are modeled as collections of objects with local state
the basic operations on pairs cons car and cdr can be used to construct list structure and to select parts from list structure but they are incapable of modifying list structure
the same is true of the list operations we have used so far such as append and list since these can be defined in terms of cons car and cdr
to modify list structures we need new operations
the primitive mutators for pairs are set car and set cdr
set car takes two arguments the first of which must be a pair
it modifies this pair replacing the car pointer by a pointer to the second argument of set car
as an example suppose that x is bound to the list and y to the list as illustrated in figure three point twelve
evaluating the expression modifies the pair to which x is bound replacing its car by the value of y
the result of the operation is shown in figure three point thirteen
the structure x has been modified and would now be printed as
the pairs representing the list identified by the pointer that was replaced are now detached from the original structure
compare figure three point thirteen with figure three point fourteen which illustrates the result of executing with x and y bound to the original lists of figure three point twelve
the variable z is now bound to a new pair created by the cons operation the list to which x is bound is unchanged
the set cdr operation is similar to set car
the only difference is that the cdr pointer of the pair rather than the car pointer is replaced
the effect of executing on the lists of figure three point twelve is shown in figure three point fifteen
here the cdr pointer of x has been replaced by the pointer to
also the list which used to be the cdr of x is now detached from the structure
cons builds new list structure by creating new pairs while set car and set cdr modify existing pairs
indeed we could implement cons in terms of the two mutators together with a procedure get new pair which returns a new pair that is not part of any existing list structure
we obtain the new pair set its car and cdr pointers to the designated objects and return the new pair as the result of the cons
the following procedure for appending lists was introduced in section two point two point one
append forms a new list by successively cons ing the elements of x onto y
the procedure append is similar to append but it is a mutator rather than a constructor
it appends the lists by splicing them together modifying the final pair of x so that its cdr is now y
here last pair is a procedure that returns the last pair in its argument
consider the interaction
what are the missing response s
draw box and pointer diagrams to explain your answer
consider the following make cycle procedure which uses the last pair procedure defined in exercise three point twelve
draw a box and pointer diagram that shows the structure z created by
what happens if we try to compute
the following procedure is quite useful although obscure
loop uses the temporary variable temp to hold the old value of the cdr of x since the set cdr on the next line destroys the cdr
explain what mystery does in general
suppose v is defined by
draw the box and pointer diagram that represents the list to which v is bound
suppose that we now evaluate
draw box and pointer diagrams that show the structures v and w after evaluating this expression
what would be printed as the values of v and w
we mentioned in section three point one point three the theoretical issues of sameness and change raised by the introduction of assignment
these issues arise in practice when individual pairs are shared among different data objects
for example consider the structure formed by
as shown in figure three point sixteen z one is a pair whose car and cdr both point to the same pair x
this sharing of x by the car and cdr of z one is a consequence of the straightforward way in which cons is implemented
in general using cons to construct lists will result in an interlinked structure of pairs in which many individual pairs are shared by many different structures
in contrast to figure three point sixteen figure three point seventeen shows the structure created by
in this structure the pairs in the two lists are distinct although the actual symbols are shared
when thought of as a list z one and z two both represent the same list
in general sharing is completely undetectable if we operate on lists using only cons car and cdr
however if we allow mutators on list structure sharing becomes significant
as an example of the difference that sharing can make consider the following procedure which modifies the car of the structure to which it is applied
even though z one and z two are the same structure applying set to wow to them yields different results
with z one altering the car also changes the cdr because in z one the car and the cdr are the same pair
with z two the car and cdr are distinct so set to wow modifies only the car
one way to detect sharing in list structures is to use the predicate eq which we introduced in section two point three point one as a way to test whether two symbols are equal
more generally tests whether x and y are the same object
thus with z one and z two as defined in figures three point sixteen and three point seventeen is true and is false
as will be seen in the following sections we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs
on the other hand sharing can also be dangerous since modifications made to structures will also affect other structures that happen to share the modified parts
the mutation operations set car and set cdr should be used with care unless we have a good understanding of how our data objects are shared mutation can have unanticipated results
draw box and pointer diagrams to explain the effect of set to wow on the structures z one and z two above
ben bitdiddle decides to write a procedure to count the number of pairs in any list structure
it's easy he reasons
the number of pairs in any structure is the number in the car plus the number in the cdr plus one more to count the current pair . so ben writes the following procedure
show that this procedure is not correct
in particular draw box and pointer diagrams representing list structures made up of exactly three pairs for which ben's procedure would return three return four return seven never return at all
devise a correct version of the count pairs procedure of exercise three point sixteen that returns the number of distinct pairs in any structure
write a procedure that examines a list and determines whether it contains a cycle that is whether a program that tried to find the end of the list by taking successive cdr s would go into an infinite loop
exercise three point thirteen constructed such lists
redo exercise three point eighteen using an algorithm that takes only a constant amount of space
when we introduced compound data we observed in section two point one point three that pairs can be represented purely in terms of procedures
the same observation is true for mutable data
we can implement mutable data objects as procedures using assignment and local state
for instance we can extend the above pair implementation to handle set car and set cdr in a manner analogous to the way we implemented bank accounts using make account in section three point one point one
assignment is all that is needed theoretically to account for the behavior of mutable data
as soon as we admit set to our language we raise all the issues not only of assignment but of mutable data in general
draw environment diagrams to illustrate the evaluation of the sequence of expressions
using the procedural implementation of pairs given above
the mutators set car and set cdr enable us to use pairs to construct data structures that cannot be built with cons car and cdr alone
this section shows how to use pairs to represent a data structure called a queue
section three point three point three will show how to represent data structures called tables
a queue is a sequence in which items are inserted at one end and deleted from the other end
figure three point eighteen shows an initially empty queue in which the items a and b are inserted
then a is removed c and d are inserted and b is removed
because items are always removed in the order in which they are inserted a queue is sometimes called a fifo buffer
in terms of data abstraction we can regard a queue as defined by the following set of operations
a constructor returns an empty queue
two selectors tests if the queue is empty
returns the object at the front of the queue signaling an error if the queue is empty it does not modify the queue
two mutators inserts the item at the rear of the queue and returns the modified queue as its value
removes the item at the front of the queue and returns the modified queue as its value signaling an error if the queue is empty before the deletion
because a queue is a sequence of items we could certainly represent it as an ordinary list the front of the queue would be the car of the list inserting an item in the queue would amount to appending a new element at the end of the list and deleting an item from the queue would just be taking the cdr of the list
however this representation is inefficient because in order to insert an item we must scan the list until we reach the end
since the only method we have for scanning a list is by successive cdr operations this scanning requires ( n ) steps for a list of n items
a simple modification to the list representation overcomes this disadvantage by allowing the queue operations to be implemented so that they require ( one ) steps that is so that the number of steps needed is independent of the length of the queue
the difficulty with the list representation arises from the need to scan to find the end of the list
the reason we need to scan is that although the standard way of representing a list as a chain of pairs readily provides us with a pointer to the beginning of the list it gives us no easily accessible pointer to the end
the modification that avoids the drawback is to represent the queue as a list together with an additional pointer that indicates the final pair in the list
that way when we go to insert an item we can consult the rear pointer and so avoid scanning the list
a queue is represented then as a pair of pointers front ptr and rear ptr which indicate respectively the first and last pairs in an ordinary list
since we would like the queue to be an identifiable object we can use cons to combine the two pointers
thus the queue itself will be the cons of the two pointers
figure three point nineteen illustrates this representation
to define the queue operations we use the following procedures which enable us to select and to modify the front and rear pointers of a queue
now we can implement the actual queue operations
we will consider a queue to be empty if its front pointer is the empty list
the make queue constructor returns as an initially empty queue a pair whose car and cdr are both the empty list
to select the item at the front of the queue we return the car of the pair indicated by the front pointer
to insert an item in a queue we follow the method whose result is indicated in figure three point twenty
we first create a new pair whose car is the item to be inserted and whose cdr is the empty list
if the queue was initially empty we set the front and rear pointers of the queue to this new pair
otherwise we modify the final pair in the queue to point to the new pair and also set the rear pointer to the new pair
to delete the item at the front of the queue we merely modify the front pointer so that it now points at the second item in the queue which can be found by following the cdr pointer of the first item
ben bitdiddle decides to test the queue implementation described above
he types in the procedures to the lisp interpreter and proceeds to try them out
it's all wrong he complains
the interpreter's response shows that the last item is inserted into the queue twice
and when i delete both items the second b is still there so the queue is n't empty even though it's supposed to be . eva lu ator suggests that ben has misunderstood what is happening
it's not that the items are going into the queue twice she explains
it's just that the standard lisp printer does n't know how to make sense of the queue representation
if you want to see the queue printed correctly you'll have to define your own print procedure for queues . explain what eva lu is talking about
in particular show why ben's examples produce the printed results that they do
define a procedure print queue that takes a queue as input and prints the sequence of items in the queue
instead of representing a queue as a pair of pointers we can build a queue as a procedure with local state
the local state will consist of pointers to the beginning and the end of an ordinary list
thus the make queue procedure will have the form
complete the definition of make queue and provide implementations of the queue operations using this representation
a deque is a sequence in which items can be inserted and deleted at either the front or the rear
operations on deques are the constructor make deque the predicate empty deque selectors front deque and rear deque and mutators front insert deque rear insert deque front delete deque and rear delete deque
show how to represent deques using pairs and give implementations of the operations
all operations should be accomplished in ( one ) steps
when we studied various ways of representing sets in chapter two we mentioned in section two point three point three the task of maintaining a table of records indexed by identifying keys
in the implementation of data directed programming in section two point four point three we made extensive use of two dimensional tables in which information is stored and retrieved using two keys
here we see how to build tables as mutable list structures
we first consider a one dimensional table in which each value is stored under a single key
we implement the table as a list of records each of which is implemented as a pair consisting of a key and the associated value
the records are glued together to form a list by pairs whose car s point to successive records
these gluing pairs are called the backbone of the table
in order to have a place that we can change when we add a new record to the table we build the table as a headed list
a headed list has a special backbone pair at the beginning which holds a dummy record in this case the arbitrarily chosen symbol table
figure three point twenty two shows the box and pointer diagram for the table
a one b two c three
to extract information from a table we use the lookup procedure which takes a key as argument and returns the associated value
lookup is defined in terms of the assoc operation which expects a key and a list of records as arguments
note that assoc never sees the dummy record
assoc returns the record that has the given key as its car
lookup then checks to see that the resulting record returned by assoc is not false and returns the value of the record
to insert a value in a table under a specified key we first use assoc to see if there is already a record in the table with this key
if not we form a new record by cons ing the key with the value and insert this at the head of the table's list of records after the dummy record
if there already is a record with this key we set the cdr of this record to the designated new value
the header of the table provides us with a fixed location to modify in order to insert the new record
to construct a new table we simply create a list containing the symbol table
in a two dimensional table each value is indexed by two keys
we can construct such a table as a one dimensional table in which each key identifies a subtable
figure three point twenty three shows the box and pointer diagram for the table
math plus forty three minus forty five multiply forty two letters a ninety seven b ninety eight
which has two subtables
when we look up an item we use the first key to identify the correct subtable
then we use the second key to identify the record within the subtable
to insert a new item under a pair of keys we use assoc to see if there is a subtable stored under the first key
if not we build a new subtable containing the single record and insert it into the table under the first key
if a subtable already exists for the first key we insert the new record into this subtable using the insertion method for one dimensional tables described above
the lookup and insert operations defined above take the table as an argument
this enables us to use programs that access more than one table
another way to deal with multiple tables is to have separate lookup and insert procedures for each table
we can do this by representing a table procedurally as an object that maintains an internal table as part of its local state
when sent an appropriate message this table object supplies the procedure with which to operate on the internal table
here is a generator for two dimensional tables represented in this fashion
using make table we could implement the get and put operations used in section two point four point three for data directed programming as follows
get takes as arguments two keys and put takes as arguments two keys and a value
both operations access the same local table which is encapsulated within the object created by the call to make table
in the table implementations above the keys are tested for equality using equal
this is not always the appropriate test
for instance we might have a table with numeric keys in which we do n't need an exact match to the number we're looking up but only a number within some tolerance of it
design a table constructor make table that takes as an argument a same key procedure that will be used to test equality of keys
make table should return a dispatch procedure that can be used to access appropriate lookup and insert procedures for a local table
generalizing one and two dimensional tables show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys
the lookup and insert procedures should take as input a list of keys used to access the table
to search a table as implemented above one needs to scan through the list of records
this is basically the unordered list representation of section two point three point three
for large tables it may be more efficient to structure the table in a different manner
describe a table implementation where the records are organized using a binary tree assuming that keys can be ordered in some way
memoization is a technique that enables a procedure to record in a local table values that have previously been computed
this technique can make a vast difference in the performance of a program
a memoized procedure maintains a table in which values of previous calls are stored using as keys the arguments that produced the values
when the memoized procedure is asked to compute a value it first checks the table to see if the value is already there and if so just returns that value
otherwise it computes the new value in the ordinary way and stores this in the table
as an example of memoization recall from section one point two point two the exponential process for computing fibonacci numbers
the memoized version of the same procedure is
where the memoizer is defined as
draw an environment diagram to analyze the computation of
explain why memo fib computes the nth fibonacci number in a number of steps proportional to n
would the scheme still work if we had simply defined memo fib to be
designing complex digital systems such as computers is an important engineering activity
digital systems are constructed by interconnecting simple elements
although the behavior of these individual elements is simple networks of them can have very complex behavior
computer simulation of proposed circuit designs is an important tool used by digital systems engineers
in this section we design a system for performing digital logic simulations
this system typifies a kind of program called an event driven simulation in which actions ( events ) trigger further events that happen at a later time which in turn trigger more events and so so
our computational model of a circuit will be composed of objects that correspond to the elementary components from which the circuit is constructed
there are wires which carry digital signals
a digital signal may at any moment have only one of two possible values 0 and one
there are also various types of digital function boxes which connect wires carrying input signals to other output wires
such boxes produce output signals computed from their input signals
the output signal is delayed by a time that depends on the type of the function box
for example an inverter is a primitive function box that inverts its input
if the input signal to an inverter changes to 0 then one inverter delay later the inverter will change its output signal to one
if the input signal to an inverter changes to one then one inverter delay later the inverter will change its output signal to 0
we draw an inverter symbolically as in figure three point twenty four
an and gate also shown in figure three point twenty four is a primitive function box with two inputs and one output
it drives its output signal to a value that is the logical and of the inputs
that is if both of its input signals become one then one and gate delay time later the and gate will force its output signal to be one otherwise the output will be 0
an or gate is a similar two input primitive function box that drives its output signal to a value that is the logical or of the inputs
that is the output will become one if at least one of the input signals is one otherwise the output will become 0
we can connect primitive functions together to construct more complex functions
to accomplish this we wire the outputs of some function boxes to the inputs of other function boxes
for example the half adder circuit shown in figure three point twenty five consists of an or gate two and gates and an inverter
it takes two input signals a and b and has two output signals s and c
s will become one whenever precisely one of a and b is one and c will become one whenever a and b are both one
we can see from the figure that because of the delays involved the outputs may be generated at different times
many of the difficulties in the design of digital circuits arise from this fact
we will now build a program for modeling the digital logic circuits we wish to study
the program will construct computational objects modeling the wires which will hold the signals
function boxes will be modeled by procedures that enforce the correct relationships among the signals
one basic element of our simulation will be a procedure make wire which constructs wires
for example we can construct six wires as follows
we attach a function box to a set of wires by calling a procedure that constructs that kind of box
the arguments to the constructor procedure are the wires to be attached to the box
for example given that we can construct and gates or gates and inverters we can wire together the half adder shown in figure three point twenty five
better yet we can explicitly name this operation by defining a procedure half adder that constructs this circuit given the four external wires to be attached to the half adder
the advantage of making this definition is that we can use half adder itself as a building block in creating more complex circuits
figure three point twenty six for example shows a full adder composed of two half adders and an or gate
we can construct a full adder as follows
having defined full adder as a procedure we can now use it as a building block for creating still more complex circuits
in essence our simulator provides us with the tools to construct a language of circuits
if we adopt the general perspective on languages with which we approached the study of lisp in section one point one we can say that the primitive function boxes form the primitive elements of the language that wiring boxes together provides a means of combination and that specifying wiring patterns as procedures serves as a means of abstraction
the primitive function boxes implement the forces by which a change in the signal on one wire influences the signals on other wires
to build function boxes we use the following operations on wires
returns the current value of the signal on the wire
changes the value of the signal on the wire to the new value
asserts that the designated procedure should be run whenever the signal on the wire changes value
such procedures are the vehicles by which changes in the signal value on the wire are communicated to other wires
in addition we will make use of a procedure after delay that takes a time delay and a procedure to be run and executes the given procedure after the given delay
using these procedures we can define the primitive digital logic functions
to connect an input to an output through an inverter we use add action to associate with the input wire a procedure that will be run whenever the signal on the input wire changes value
the procedure computes the logical not of the input signal and then after one inverter delay sets the output signal to be this new value
an and gate is a little more complex
the action procedure must be run if either of the inputs to the gate changes
it computes the logical and of the values of the signals on the input wires and sets up a change to the new value to occur on the output wire after one and gate delay
define an or gate as a primitive function box
your or gate constructor should be similar to and gate
another way to construct an or gate is as a compound digital logic device built from and gates and inverters
define a procedure or gate that accomplishes this
what is the delay time of the or gate in terms of and gate delay and inverter delay
figure three point twenty seven shows a ripple carry adder formed by stringing together n full adders
this is the simplest form of parallel adder for adding two n bit binary numbers
the inputs a one a two a three ... an and b one b two b three ... bn are the two binary numbers to be added
the circuit generates s one s two s three ... sn the n bits of the sum and c the carry from the addition
write a procedure ripple carry adder that generates this circuit
the procedure should take as arguments three lists of n wires each the ak the bk and the sk and also another wire c
the major drawback of the ripple carry adder is the need to wait for the carry signals to propagate
what is the delay needed to obtain the complete output from an n bit ripple carry adder expressed in terms of the delays for and gates or gates and inverters
a wire in our simulation will be a computational object with two local state variables a signal value and a collection of action procedures to be run when the signal changes value
we implement the wire using message passing style as a collection of local procedures together with a dispatch procedure that selects the appropriate local operation just as we did with the simple bank account object in section three point one point one
the local procedure set my signal tests whether the new signal value changes the signal on the wire
if so it runs each of the action procedures using the following procedure call each which calls each of the items in a list of no argument procedures
the local procedure accept action procedure adds the given procedure to the list of procedures to be run and then runs the new procedure once
with the local dispatch procedure set up as specified we can provide the following procedures to access the local operations on wires
wires which have time varying signals and may be incrementally attached to devices are typical of mutable objects
we have modeled them as procedures with local state variables that are modified by assignment
when a new wire is created a new set of state variables is allocated and a new dispatch procedure is constructed and returned capturing the environment with the new state variables
the wires are shared among the various devices that have been connected to them
thus a change made by an interaction with one device will affect all the other devices attached to the wire
the wire communicates the change to its neighbors by calling the action procedures provided to it when the connections were established
the only thing needed to complete the simulator is after delay
the idea here is that we maintain a data structure called an agenda that contains a schedule of things to do
the following operations are defined for agendas
returns a new empty agenda
is true if the specified agenda is empty
returns the first item on the agenda
modifies the agenda by removing the first item
modifies the agenda by adding the given action procedure to be run at the specified time
returns the current simulation time
the particular agenda that we use is denoted by the agenda
the procedure after delay adds new elements to the agenda
the simulation is driven by the procedure propagate which operates on the agenda executing each procedure on the agenda in sequence
in general as the simulation runs new items will be added to the agenda and propagate will continue the simulation as long as there are items on the agenda
the following procedure which places a probe on a wire shows the simulator in action
the probe tells the wire that whenever its signal changes value it should print the new signal value together with the current time and a name that identifies the wire
we begin by initializing the agenda and specifying delays for the primitive function boxes
now we define four wires placing probes on two of them
next we connect the wires in a half adder circuit set the signal on input one to one and run the simulation
the sum signal changes to one at time eight
we are now eight time units from the beginning of the simulation
at this point we can set the signal on input two to one and allow the values to propagate
the carry changes to one at time eleven and the sum changes to 0 at time sixteen
the internal procedure accept action procedure defined in make wire specifies that when a new action procedure is added to a wire the procedure is immediately run
explain why this initialization is necessary
in particular trace through the half adder example in the paragraphs above and say how the system's response would differ if we had defined accept action procedure as
finally we give details of the agenda data structure which holds the procedures that are scheduled for future execution
the agenda is made up of time segments
each time segment is a pair consisting of a number and a queue that holds the procedures that are scheduled to be run during that time segment
we will operate on the time segment queues using the queue operations described in section three point three point two
the agenda itself is a one dimensional table of time segments
it differs from the tables described in section three point three point three in that the segments will be sorted in order of increasing time
in addition we store the current time at the head of the agenda
a newly constructed agenda has no time segments and has a current time of 0
an agenda is empty if it has no time segments
to add an action to an agenda we first check if the agenda is empty
if so we create a time segment for the action and install this in the agenda
otherwise we scan the agenda examining the time of each segment
if we find a segment for our appointed time we add the action to the associated queue
if we reach a time later than the one to which we are appointed we insert a new time segment into the agenda just before it
if we reach the end of the agenda we must create a new time segment at the end
the procedure that removes the first item from the agenda deletes the item at the front of the queue in the first time segment
if this deletion makes the time segment empty we remove it from the list of segments
the first agenda item is found at the head of the queue in the first time segment
whenever we extract an item we also update the current time
the procedures to be run during each time segment of the agenda are kept in a queue
thus the procedures for each segment are called in the order in which they were added to the agenda
explain why this order must be used
in particular trace the behavior of an and gate whose inputs change from 0 one to one 0 in the same segment and say how the behavior would differ if we stored a segment's procedures in an ordinary list adding and removing procedures only at the front
computer programs are traditionally organized as one directional computations which perform operations on prespecified arguments to produce desired outputs
on the other hand we often model systems in terms of relations among quantities
for example a mathematical model of a mechanical structure might include the information that the deflection d of a metal rod is related to the force f on the rod the length l of the rod the cross sectional area a and the elastic modulus e via the equation
such an equation is not one directional
given any four of the quantities we can use it to compute the fifth
yet translating the equation into a traditional computer language would force us to choose one of the quantities to be computed in terms of the other four
thus a procedure for computing the area a could not be used to compute the deflection d even though the computations of a and d arise from the same equation
in this section we sketch the design of a language that enables us to work in terms of relations themselves
the primitive elements of the language are primitive constraints which state that certain relations hold between quantities
for example specifies that the quantities a b and c must be related by the equation a plus b equal c expresses the constraint xy equal z and says that the value of x must be 3.14
our language provides a means of combining primitive constraints in order to express more complex relations
we combine constraints by constructing constraint networks in which constraints are joined by connectors
a connector is an object that holds a value that may participate in one or more constraints
for example we know that the relationship between fahrenheit and celsius temperatures is
such a constraint can be thought of as a network consisting of primitive adder multiplier and constant constraints
in the figure we see on the left a multiplier box with three terminals labeled m one m two and p
these connect the multiplier to the rest of the network as follows the m one terminal is linked to a connector c which will hold the celsius temperature
the m two terminal is linked to a connector w which is also linked to a constant box that holds nine
the p terminal which the multiplier box constrains to be the product of m one and m two is linked to the p terminal of another multiplier box whose m two is connected to a constant five and whose m one is connected to one of the terms in a sum
computation by such a network proceeds as follows when a connector is given a value it awakens all of its associated constraints to inform them that it has a value
each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector
if so the box sets that connector which then awakens all of its associated constraints and so on
for instance in conversion between celsius and fahrenheit w x and y are immediately set by the constant boxes to nine five and thirty two respectively
the connectors awaken the multipliers and the adder which determine that there is not enough information to proceed
if the user sets c to a value the leftmost multiplier will be awakened and it will set u to twenty five &middot nine equal two hundred twenty five
then u awakens the second multiplier which sets v to forty five and v awakens the adder which sets f to seventy seven
to use the constraint system to carry out the temperature computation outlined above we first create two connectors c and f by calling the constructor make connector and link c and f in an appropriate network
the procedure that creates the network is defined as follows
this procedure creates the internal connectors u v w x and y and links them as shown in figure three point twenty eight using the primitive constraint constructors adder multiplier and constant
just as with the digital circuit simulator of section three point three point four expressing these combinations of primitive elements in terms of procedures automatically provides our language with a means of abstraction for compound objects
to watch the network in action we can place probes on the connectors c and f using a probe procedure similar to the one we used to monitor wires in section three point three point four
placing a probe on a connector will cause a message to be printed whenever the connector is given a value
next we set the value of c to twenty five
the probe on c awakens and reports the value
c also propagates its value through the network as described above
this sets f to seventy seven which is reported by the probe on f
now we can try to set f to a new value say two hundred twelve
the connector complains that it has sensed a contradiction its value is seventy seven and someone is trying to set it to two hundred twelve
if we really want to reuse the network with new values we can tell c to forget its old value
c finds that the user who set its value originally is now retracting that value so c agrees to lose its value as shown by the probe and informs the rest of the network of this fact
this information eventually propagates to f which now finds that it has no reason for continuing to believe that its own value is seventy seven
thus f also gives up its value as shown by the probe
now that f has no value we are free to set it to two hundred twelve
this new value when propagated through the network forces c to have a value of one hundred and this is registered by the probe on c
notice that the very same network is being used to compute c given f and to compute f given c
this nondirectionality of computation is the distinguishing feature of constraint based systems
the constraint system is implemented via procedural objects with local state in a manner very similar to the digital circuit simulator of section three point three point four
although the primitive objects of the constraint system are somewhat more complex the overall system is simpler since there is no concern about agendas and logic delays
the basic operations on connectors are the following
tells whether the connector has a value
returns the connector's current value
indicates that the informant is requesting the connector to set its value to the new value
tells the connector that the retractor is requesting it to forget its value
tells the connector to participate in the new constraint
the connectors communicate with the constraints by means of the procedures inform about value which tells the given constraint that the connector has a value and inform about no value which tells the constraint that the connector has lost its value
adder constructs an adder constraint among summand connectors a one and a two and a sum connector
an adder is implemented as a procedure with local state
adder connects the new adder to the designated connectors and returns it as its value
the procedure me which represents the adder acts as a dispatch to the local procedures
the following syntax interfaces are used in conjunction with the dispatch
the adder's local procedure process new value is called when the adder is informed that one of its connectors has a value
the adder first checks to see if both a one and a two have values
if so it tells sum to set its value to the sum of the two addends
the informant argument to set value is me which is the adder object itself
if a one and a two do not both have values then the adder checks to see if perhaps a one and sum have values
if so it sets a two to the difference of these two
finally if a two and sum have values this gives the adder enough information to set a one
if the adder is told that one of its connectors has lost a value it requests that all of its connectors now lose their values
then it runs process new value
the reason for this last step is that one or more connectors may still have a value and these values may need to be propagated back through the adder
a multiplier is very similar to an adder
it will set its product to 0 if either of the factors is 0 even if the other factor is not known
a constant constructor simply sets the value of the designated connector
any i have a value or i lost my value message sent to the constant box will produce an error
finally a probe prints a message about the setting or unsetting of the designated connector
a connector is represented as a procedural object with local state variables value the current value of the connector informant the object that set the connector's value and constraints a list of the constraints in which the connector participates
the connector's local procedure set my value is called when there is a request to set the connector's value
if the connector does not currently have a value it will set its value and remember as informant the constraint that requested the value to be set
then the connector will notify all of its participating constraints except the constraint that requested the value to be set
this is accomplished using the following iterator which applies a designated procedure to all items in a list except a given one
if a connector is asked to forget its value it runs the local procedure forget my value which first checks to make sure that the request is coming from the same object that set the value originally
if so the connector informs its associated constraints about the loss of the value
the local procedure connect adds the designated new constraint to the list of constraints if it is not already in that list
then if the connector has a value it informs the new constraint of this fact
the connector's procedure me serves as a dispatch to the other internal procedures and also represents the connector as an object
the following procedures provide a syntax interface for the dispatch
using primitive multiplier adder and constant constraints define a procedure averager that takes three connectors a b and c as inputs and establishes the constraint that the value of c is the average of the values of a and b
louis reasoner wants to build a squarer a constraint device with two terminals such that the value of connector b on the second terminal will always be the square of the value a on the first terminal
he proposes the following simple device made from a multiplier
there is a serious flaw in this idea
explain
ben bitdiddle tells louis that one way to avoid the trouble in exercise three point thirty four is to define a squarer as a new primitive constraint
fill in the missing portions in ben's outline for a procedure to implement such a constraint
suppose we evaluate the following sequence of expressions in the global environment
at some time during evaluation of the set value the following expression from the connector's local procedure is evaluated
draw an environment diagram showing the environment in which the above expression is evaluated
the celsius fahrenheit converter procedure is cumbersome when compared with a more expression oriented style of definition such as
here c+ c* etc
are the constraint versions of the arithmetic operations
for example c+ takes two connectors as arguments and returns a connector that is related to these by an adder constraint
define analogous procedures c c* c / and cv that enable us to define compound constraints as in the converter example above
