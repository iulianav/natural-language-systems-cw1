we've gained a good understanding of assignment as a tool in modeling as well as an appreciation of the complex problems that assignment raises
it is time to ask whether we could have gone about things in a different way so as to avoid some of these problems
in this section we explore an alternative approach to modeling state based on data structures called streams
as we shall see streams can mitigate some of the complexity of modeling state
let's step back and review where this complexity comes from
in an attempt to model real world phenomena we made some apparently reasonable decisions we modeled real world objects with local state by computational objects with local variables
we identified time variation in the real world with time variation in the computer
we implemented the time variation of the states of the model objects in the computer with assignments to the local variables of the model objects
is there another approach
can we avoid identifying time in the computer with time in the modeled world
must we make the model change with time in order to model phenomena in a changing world
think about the issue in terms of mathematical functions
we can describe the time varying behavior of a quantity x as a function of time x ( t )
if we concentrate on x instant by instant we think of it as a changing quantity
yet if we concentrate on the entire time history of values we do not emphasize change the function itself does not change
if time is measured in discrete steps then we can model a time function as a sequence
in this section we will see how to model change in terms of sequences that represent the time histories of the systems being modeled
to accomplish this we introduce new data structures called streams
from an abstract point of view a stream is simply a sequence
however we will find that the straightforward implementation of streams as lists does n't fully reveal the power of stream processing
as an alternative we introduce the technique of delayed evaluation which enables us to represent very large sequences as streams
stream processing lets us model systems that have state without ever using assignment or mutable data
this has important implications both theoretical and practical because we can build models that avoid the drawbacks inherent in introducing assignment
on the other hand the stream framework raises difficulties of its own and the question of which modeling technique leads to more modular and more easily maintained systems remains open
as we saw in section two point two point three sequences can serve as standard interfaces for combining program modules
we formulated powerful abstractions for manipulating sequences such as map filter and accumulate that capture a wide variety of operations in a manner that is both succinct and elegant
unfortunately if we represent sequences as lists this elegance is bought at the price of severe inefficiency with respect to both the time and space required by our computations
when we represent manipulations on sequences as transformations of lists our programs must construct and copy data structures at every step of a process
to see why this is true let us compare two programs for computing the sum of all the prime numbers in an interval
the first program is written in standard iterative style
the second program performs the same computation using the sequence operations of section two point two point three
in carrying out the computation the first program needs to store only the sum being accumulated
in contrast the filter in the second program cannot do any testing until enumerate interval has constructed a complete list of the numbers in the interval
the filter generates another list which in turn is passed to accumulate before being collapsed to form a sum
such large intermediate storage is not needed by the first program which we can think of as enumerating the interval incrementally adding each prime to the sum as it is generated
the inefficiency in using lists becomes painfully apparent if we use the sequence paradigm to compute the second prime in the interval from ten 0 hundred to one 0 hundred 000 by evaluating the expression
this expression does find the second prime but the computational overhead is outrageous
we construct a list of almost a million integers filter this list by testing each element for primality and then ignore almost all of the result
in a more traditional programming style we would interleave the enumeration and the filtering and stop when we reached the second prime
streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists
with streams we can achieve the best of both worlds we can formulate programs elegantly as sequence manipulations while attaining the efficiency of incremental computation
the basic idea is to arrange to construct a stream only partially and to pass the partial construction to the program that consumes the stream
if the consumer attempts to access a part of the stream that has not yet been constructed the stream will automatically construct just enough more of itself to produce the required part thus preserving the illusion that the entire stream exists
in other words although we will write programs as if we were processing complete sequences we design our stream implementation to automatically and transparently interleave the construction of the stream with its use
on the surface streams are just lists with different names for the procedures that manipulate them
there is a constructor cons stream and two selectors stream car and stream cdr which satisfy the constraints
there is a distinguishable object the empty stream which cannot be the result of any cons stream operation and which can be identified with the predicate stream null
thus we can make and use streams in just the same way as we can make and use lists to represent aggregate data arranged in a sequence
in particular we can build stream analogs of the list operations from chapter two such as list ref map and for each
stream for each is useful for viewing streams
to make the stream implementation automatically and transparently interleave the construction of a stream with its use we will arrange for the cdr of a stream to be evaluated when it is accessed by the stream cdr procedure rather than when the stream is constructed by cons stream
this implementation choice is reminiscent of our discussion of rational numbers in section two point one point two where we saw that we can choose to implement rational numbers so that the reduction of numerator and denominator to lowest terms is performed either at construction time or at selection time
the two rational number implementations produce the same data abstraction but the choice has an effect on efficiency
there is a similar relationship between streams and ordinary lists
as a data abstraction streams are the same as lists
the difference is the time at which the elements are evaluated
with ordinary lists both the car and the cdr are evaluated at construction time
with streams the cdr is evaluated at selection time
our implementation of streams will be based on a special form called delay
evaluating does not evaluate the expression exp but rather returns a so called delayed object which we can think of as a promise to evaluate exp at some future time
as a companion to delay there is a procedure called force that takes a delayed object as argument and performs the evaluation in effect forcing the delay to fulfill its promise
we will see below how delay and force can be implemented but first let us use these to construct streams
cons stream is a special form defined so that
is equivalent to
what this means is that we will construct streams using pairs
however rather than placing the value of the rest of the stream into the cdr of the pair we will put there a promise to compute the rest if it is ever requested
stream car and stream cdr can now be defined as procedures
stream car selects the car of the pair stream cdr selects the cdr of the pair and evaluates the delayed expression found there to obtain the rest of the stream
to see how this implementation behaves let us analyze the outrageous prime computation we saw above reformulated in terms of streams
we will see that it does indeed work efficiently
we begin by calling stream enumerate interval with the arguments ten 0 hundred and one 0 hundred 000
stream enumerate interval is the stream analog of enumerate interval
and thus the result returned by stream enumerate interval formed by the cons stream is
that is stream enumerate interval returns a stream represented as a pair whose car is ten 0 hundred and whose cdr is a promise to enumerate more of the interval if so requested
this stream is now filtered for primes using the stream analog of the filter procedure
stream filter tests the stream car of the stream
since this is not prime stream filter examines the stream cdr of its input stream
the call to stream cdr forces evaluation of the delayed stream enumerate interval which now returns
stream filter now looks at the stream car of this stream ten 0 hundred and one sees that this is not prime either forces another stream cdr and so on until stream enumerate interval yields the prime ten 0 hundred and seven whereupon stream filter according to its definition returns
which in this case is
this result is now passed to stream cdr in our original expression
this forces the delayed stream filter which in turn keeps forcing the delayed stream enumerate interval until it finds the next prime which is ten 0 hundred and nine
finally the result passed to stream car in our original expression is
stream car returns ten 0 hundred and nine and the computation is complete
only as many integers were tested for primality as were necessary to find the second prime and the interval was enumerated only as far as was necessary to feed the prime filter
in general we can think of delayed evaluation as demand driven programming whereby each stage in the stream process is activated only enough to satisfy the next stage
what we have done is to decouple the actual order of events in the computation from the apparent structure of our procedures
we write procedures as if the streams existed all at once when in reality the computation is performed incrementally as in traditional programming styles
although delay and force may seem like mysterious operations their implementation is really quite straightforward
delay must package an expression so that it can be evaluated later on demand and we can accomplish this simply by treating the expression as the body of a procedure
delay can be a special form such that
is syntactic sugar for
force simply calls the procedure produced by delay so we can implement force as a procedure
this implementation suffices for delay and force to work as advertised but there is an important optimization that we can include
in many applications we end up forcing the same delayed object many times
this can lead to serious inefficiency in recursive programs involving streams
the solution is to build delayed objects so that the first time they are forced they store the value that is computed
subsequent forcings will simply return the stored value without repeating the computation
in other words we implement delay as a special purpose memoized procedure similar to the one described in exercise three point twenty seven
one way to accomplish this is to use the following procedure which takes as argument a procedure and returns a memoized version of the procedure
the first time the memoized procedure is run it saves the computed result
on subsequent evaluations it simply returns the result
delay is then defined so that is equivalent to
and force is as defined previously
complete the following definition which generalizes stream map to allow procedures that take multiple arguments analogous to map in section two point two point three footnote twelve
in order to take a closer look at delayed evaluation we will use the following procedure which simply returns its argument after printing it
what does the interpreter print in response to evaluating each expression in the following sequence
consider the sequence of expressions
what is the value of sum after each of the above expressions is evaluated
what is the printed response to evaluating the stream ref and display stream expressions
would these responses differ if we had implemented simply as without using the optimization provided by memo proc
explain
we have seen how to support the illusion of manipulating streams as complete entities even though in actuality we compute only as much of the stream as we need to access
we can exploit this technique to represent sequences efficiently as streams even if the sequences are very long
what is more striking we can use streams to represent sequences that are infinitely long
for instance consider the following definition of the stream of positive integers
this makes sense because integers will be a pair whose car is one and whose cdr is a promise to produce the integers beginning with two
this is an infinitely long stream but in any given time we can examine only a finite portion of it
thus our programs will never know that the entire infinite stream is not there
using integers we can define other infinite streams such as the stream of integers that are not divisible by seven
then we can find integers not divisible by seven simply by accessing elements of this stream
in analogy with integers we can define the infinite stream of fibonacci numbers
fibs is a pair whose car is 0 and whose cdr is a promise to evaluate
when we evaluate this delayed it will produce a pair whose car is one and whose cdr is a promise to evaluate and so on
for a look at a more exciting infinite stream we can generalize the no sevens example to construct the infinite stream of prime numbers using a method known as the sieve of eratosthenes
we start with the integers beginning with two which is the first prime
to get the rest of the primes we start by filtering the multiples of two from the rest of the integers
this leaves a stream beginning with three which is the next prime
now we filter the multiples of three from the rest of this stream
this leaves a stream beginning with five which is the next prime and so on
in other words we construct the primes by a sieving process described as follows to sieve a stream s form a stream whose first element is the first element of s and the rest of which is obtained by filtering all multiples of the first element of s out of the rest of s and sieving the result
this process is readily described in terms of stream operations
now to find a particular prime we need only ask for it
it is interesting to contemplate the signal processing system set up by sieve shown in the henderson diagram in figure three point thirty one
the input stream feeds into an un cons er that separates the first element of the stream from the rest of the stream
the first element is used to construct a divisibility filter through which the rest is passed and the output of the filter is fed to another sieve box
then the original first element is cons ed onto the output of the internal sieve to form the output stream
thus not only is the stream infinite but the signal processor is also infinite because the sieve contains a sieve within it
the integers and fibs streams above were defined by specifying generating procedures that explicitly compute the stream elements one by one
an alternative way to specify streams is to take advantage of delayed evaluation to define streams implicitly
for example the following expression defines the stream ones to be an infinite stream of ones
this works much like the definition of a recursive procedure ones is a pair whose car is one and whose cdr is a promise to evaluate ones
evaluating the cdr gives us again a one and a promise to evaluate ones and so on
we can do more interesting things by manipulating streams with operations such as add streams which produces the elementwise sum of two given streams
now we can define the integers as follows
this defines integers to be a stream whose first element is one and the rest of which is the sum of ones and integers
thus the second element of integers is one plus the first element of integers or two the third element of integers is one plus the second element of integers or three and so on
this definition works because at any point enough of the integers stream has been generated so that we can feed it back into the definition to produce the next integer
we can define the fibonacci numbers in the same style
this definition says that fibs is a stream beginning with 0 and one such that the rest of the stream can be generated by adding fibs to itself shifted by one place
one 1 two three five eight thirteen twenty one ... equal
0 one 1 two three five eight thirteen ... equal fibs
0 one 1 two three five eight thirteen twenty one 34 ... equal fibs
scale stream is another useful procedure in formulating such stream definitions
this multiplies each item in a stream by a given constant
for example
produces the stream of powers of two one two four eight sixteen thirty two ...
an alternate definition of the stream of primes can be given by starting with the integers and filtering them by testing for primality
we will need the first prime two to get started
this definition is not so straightforward as it appears because we will test whether a number n is prime by checking whether n is divisible by a prime less than or equal to n
this is a recursive definition since primes is defined in terms of the prime predicate which itself uses the primes stream
the reason this procedure works is that at any point enough of the primes stream has been generated to test the primality of the numbers we need to check next
that is for every n we test for primality either n is not prime or n is prime
without running the program describe the elements of the stream defined by
define a procedure mul streams analogous to add streams that produces the elementwise product of its two input streams
use this together with the stream of integers to complete the following definition of the stream whose nth element is n plus one factorial
define a procedure partial sums that takes as argument a stream s and returns the stream whose elements are s 0 s 0 plus s one s 0 plus s one plus s two ...
for example should be the stream one three six ten fifteen ...
a famous problem first raised by r
hamming is to enumerate in ascending order with no repetitions all positive integers with no prime factors other than two three or five
one obvious way to do this is to simply test each integer in turn to see whether it has any factors other than two three and five
but this is very inefficient since as the integers get larger fewer and fewer of them fit the requirement
as an alternative let us call the required stream of numbers s and notice the following facts about it
s begins with one
the elements of are also elements of s
the same is true for and
these are all the elements of s
now all we have to do is combine elements from these sources
for this we define a procedure merge that combines two ordered streams into one ordered result stream eliminating repetitions
then the required stream may be constructed with merge as follows
fill in the missing expressions in the places marked <> above
how many additions are performed when we compute the nth fibonacci number using the definition of fibs based on the add streams procedure
show that the number of additions would be exponentially greater if we had implemented simply as without using the optimization provided by the memo proc procedure described in section three point five point one
give an interpretation of the stream computed by the following procedure
what are the successive elements produced by
what is produced by
in section two point five point three we saw how to implement a polynomial arithmetic system representing polynomials as lists of terms
in a similar way we can work with power series such as
represented as infinite streams
we will represent the series a 0 plus a one x plus a two x two plus a three x three plus &middot &middot &middot as the stream whose elements are the coefficients a 0 a one a two a three ...
a
the integral of the series a 0 plus a one x plus a two x two plus a three x three plus &middot &middot &middot is the series
where c is any constant
define a procedure integrate series that takes as input a stream a 0 a one a two ... representing a power series and returns the stream a 0 ( one / two ) a one ( one / three ) a two ... of coefficients of the non constant terms of the integral of the series
b
the function x ex is its own derivative
this implies that ex and the integral of ex are the same series except for the constant term which is e 0 equal one
accordingly we can generate the series for ex as
show how to generate the series for sine and cosine starting from the facts that the derivative of sine is cosine and the derivative of cosine is the negative of sine
with power series represented as streams of coefficients as in exercise three point fifty nine adding series is implemented by add streams
complete the definition of the following procedure for multiplying series
you can test your procedure by verifying that sin two x plus cos two x equal one using the series from exercise three point fifty nine
let s be a power series whose constant term is one
suppose we want to find the power series one / s that is the series x such that s &middot x equal one
write s equal one plus sr where sr is the part of s after the constant term
then we can solve for x as follows
in other words x is the power series whose constant term is one and whose higher order terms are given by the negative of sr times x
use this idea to write a procedure invert unit series that computes one / s for a power series s with constant term one
you will need to use mul series from exercise three point sixty
use the results of exercises three point sixty and three point sixty one to define a procedure div series that divides two power series
div series should work for any two series provided that the denominator series begins with a nonzero constant term
show how to use div series together with the result of exercise three point fifty nine to generate the power series for tangent
streams with delayed evaluation can be a powerful modeling tool providing many of the benefits of local state and assignment
moreover they avoid some of the theoretical tangles that accompany the introduction of assignment into a programming language
the stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables
for example we can think of an entire time series as a focus of interest rather than the values of the state variables at individual moments
this makes it convenient to combine and compare components of state from different moments
in section one point two point one we introduced iterative processes which proceed by updating state variables
we know now that we can represent state as a timeless stream of values rather than as a set of variables to be updated
let's adopt this perspective in revisiting the square root procedure from section one point one point seven
recall that the idea is to generate a sequence of better and better guesses for the square root of x by applying over and over again the procedure that improves guesses
in our original sqrt procedure we made these guesses be the successive values of a state variable
instead we can generate the infinite stream of guesses starting with an initial guess of one
we can generate more and more terms of the stream to get better and better guesses
if we like we can write a procedure that keeps generating terms until the answer is good enough
another iteration that we can treat in the same way is to generate an approximation to based upon the alternating series that we saw in section one point three point one
we first generate the stream of summands of the series
then we take the stream of sums of more and more terms and scale the result by four
this gives us a stream of better and better approximations to although the approximations converge rather slowly
eight terms of the sequence bound the value of between 3.284 and 3.017
so far our use of the stream of states approach is not much different from updating state variables
but streams give us an opportunity to do some interesting tricks
for example we can transform a stream with a sequence accelerator that converts a sequence of approximations to a new sequence that converges to the same value as the original only faster
one such accelerator due to the eighteenth century swiss mathematician leonhard euler works well with sequences that are partial sums of alternating series
in euler's technique if sn is the nth term of the original sum sequence then the accelerated sequence has terms
thus if the original sequence is represented as a stream of values the transformed sequence is given by
we can demonstrate euler acceleration with our sequence of approximations to
even better we can accelerate the accelerated sequence and recursively accelerate that and so on
namely we create a stream of streams in which each stream is the transform of the preceding one
the tableau has the form
finally we form a sequence by taking the first term in each row of the tableau
we can demonstrate this kind of super acceleration of the sequence
the result is impressive
taking eight terms of the sequence yields the correct value of to fourteen decimal places
if we had used only the original sequence we would need to compute on the order of 1013 terms to get that much accuracy
we could have implemented these acceleration techniques without using streams
but the stream formulation is particularly elegant and convenient because the entire sequence of states is available to us as a data structure that can be manipulated with a uniform set of operations
louis reasoner asks why the sqrt stream procedure was not written in the following more straightforward way without the local variable guesses
alyssa p
hacker replies that this version of the procedure is considerably less efficient because it performs redundant computation
explain alyssa's answer
would the two versions still differ in efficiency if our implementation of delay used only without using the optimization provided by memo proc
write a procedure stream limit that takes as arguments a stream and a number
it should examine the stream until it finds two successive elements that differ in absolute value by less than the tolerance and return the second of the two elements
using this we could compute square roots up to a given tolerance by
use the series
to compute three sequences of approximations to the natural logarithm of two in the same way we did above for
how rapidly do these sequences converge
in section two point two point three we saw how the sequence paradigm handles traditional nested loops as processes defined on sequences of pairs
if we generalize this technique to infinite streams then we can write programs that are not easily represented as loops because the looping must range over an infinite set
for example suppose we want to generalize the prime sum pairs procedure of section two point two point three to produce the stream of pairs of all integers ( i j ) with i < j such that i plus j is prime
if int pairs is the sequence of all pairs of integers ( i j ) with i < j then our required stream is simply
our problem then is to produce the stream int pairs
more generally suppose we have two streams s equal ( si ) and t equal ( tj ) and imagine the infinite rectangular array
we wish to generate a stream that contains all the pairs in the array that lie on or above the diagonal i.e. the pairs
call the general stream of pairs and consider it to be composed of three parts the pair ( s 0 t 0 ) the rest of the pairs in the first row and the remaining pairs
observe that the third piece in this decomposition is ( recursively ) the pairs formed from and
also note that the second piece is
thus we can form our stream of pairs as follows
in order to complete the procedure we must choose some way to combine the two inner streams
one idea is to use the stream analog of the append procedure from section two point two point one
this is unsuitable for infinite streams however because it takes all the elements from the first stream before incorporating the second stream
in particular if we try to generate all pairs of positive integers using
our stream of results will first try to run through all pairs with the first integer equal to one and hence will never produce pairs with any other value of the first integer
to handle infinite streams we need to devise an order of combination that ensures that every element will eventually be reached if we let our program run long enough
an elegant way to accomplish this is with the following interleave procedure
since interleave takes elements alternately from the two streams every element of the second stream will eventually find its way into the interleaved stream even if the first stream is infinite
we can thus generate the required stream of pairs as
examine the stream
can you make any general comments about the order in which the pairs are placed into the stream
for example about how many pairs precede the pair ( one 1 hundred )
the pair ( ninety nine one hundred )
the pair ( one hundred 100 )
modify the pairs procedure so that will produce the stream of all pairs of integers ( i j )
hint you will need to mix in an additional stream
louis reasoner thinks that building a stream of pairs from three parts is unnecessarily complicated
instead of separating the pair ( s 0 t 0 ) from the rest of the pairs in the first row he proposes to work with the whole first row as follows
does this work
consider what happens if we evaluate using louis's definition of pairs
write a procedure triples that takes three infinite streams s t and u and produces the stream of triples ( si tj uk ) such that i < j < k
use triples to generate the stream of all pythagorean triples of positive integers i.e. the triples ( i j k ) such that i < j and i two plus j two equal k two
it would be nice to be able to generate streams in which the pairs appear in some useful order rather than in the order that results from an ad hoc interleaving process
we can use a technique similar to the merge procedure of exercise three point fifty six if we define a way to say that one pair of integers is less than another
one way to do this is to define a weighting function w ( i j ) and stipulate that ( i one j one ) is less than ( i two j two ) if w ( i one j one ) < w ( i two j two )
write a procedure merge weighted that is like merge except that merge weighted takes an additional argument weight which is a procedure that computes the weight of a pair and is used to determine the order in which elements should appear in the resulting merged stream
using this generalize pairs to a procedure weighted pairs that takes two streams together with a procedure that computes a weighting function and generates the stream of pairs ordered according to weight
use your procedure to generate
a
the stream of all pairs of positive integers ( i j ) with i < j ordered according to the sum i plus j
b
the stream of all pairs of positive integers ( i j ) with i < j where neither i nor j is divisible by two three or five and the pairs are ordered according to the sum two i plus three j plus five i j
numbers that can be expressed as the sum of two cubes in more than one way are sometimes called ramanujan numbers in honor of the mathematician srinivasa ramanujan
ordered streams of pairs provide an elegant solution to the problem of computing these numbers
to find a number that can be written as the sum of two cubes in two different ways we need only generate the stream of pairs of integers ( i j ) weighted according to the sum i three plus j three then search the stream for two consecutive pairs with the same weight
write a procedure to generate the ramanujan numbers
the first such number is one seven hundred twenty nine
what are the next five
in a similar way to exercise three point seventy one generate a stream of all numbers that can be written as the sum of two squares in three different ways
we began our discussion of streams by describing them as computational analogs of the signals in signal processing systems
in fact we can use streams to model signal processing systems in a very direct way representing the values of a signal at successive time intervals as consecutive elements of a stream
for instance we can implement an integrator or summer that for an input stream x equal ( xi ) an initial value c and a small increment dt accumulates the sum
and returns the stream of values s equal ( si )
the following integral procedure is reminiscent of the implicit style definition of the stream of integers
figure three point thirty two is a picture of a signal processing system that corresponds to the integral procedure
the input stream is scaled by dt and passed through an adder whose output is passed back through the same adder
the self reference in the definition of int is reflected in the figure by the feedback loop that connects the output of the adder to one of the inputs
we can model electrical circuits using streams to represent the values of currents or voltages at a sequence of times
for instance suppose we have an rc circuit consisting of a resistor of resistance r and a capacitor of capacitance c in series
the voltage response v of the circuit to an injected current i is determined by the formula in figure three point thirty three whose structure is shown by the accompanying signal flow diagram
write a procedure rc that models this circuit
rc should take as inputs the values of r c and dt and should return a procedure that takes as inputs a stream representing the current i and an initial value for the capacitor voltage v 0 and produces as output the stream of voltages v
for example you should be able to use rc to model an rc circuit with r equal five ohms c equal one farad and a 0.5 second time step by evaluating
this defines rc one as a procedure that takes a stream representing the time sequence of currents and an initial capacitor voltage and produces the output stream of voltages
alyssa p
hacker is designing a system to process signals coming from physical sensors
one important feature she wishes to produce is a signal that describes the zero crossings of the input signal
that is the resulting signal should be plus one whenever the input signal changes from negative to positive minus one whenever the input signal changes from positive to negative and 0 otherwise
for example a typical input signal with its associated zero crossing signal would be
< ... one two 1.5 one 0.5 0.1 two three two 0.5 0.2 three four ... ... 0 0 0 0 0 one 0 0 0 0 one 0 0 ... >
in alyssa's system the signal from the sensor is represented as a stream sense data and the stream zero crossings is the corresponding stream of zero crossings
alyssa first writes a procedure sign change detector that takes two values as arguments and compares the signs of the values to produce an appropriate 0 one or minus one
she then constructs her zero crossing stream as follows
alyssa's boss eva lu ator walks by and suggests that this program is approximately equivalent to the following one which uses the generalized version of stream map from exercise three point fifty
complete the program by supplying the indicated
unfortunately alyssa's zero crossing detector in exercise three point seventy four proves to be insufficient because the noisy signal from the sensor leads to spurious zero crossings
lem e
tweakit a hardware specialist suggests that alyssa smooth the signal to filter out the noise before extracting the zero crossings
alyssa takes his advice and decides to extract the zero crossings from the signal constructed by averaging each value of the sense data with the previous value
she explains the problem to her assistant louis reasoner who attempts to implement the idea altering alyssa's program as follows
this does not correctly implement alyssa's plan
find the bug that louis has installed and fix it without changing the structure of the program
eva lu ator has a criticism of louis's approach in exercise three point seventy five
the program he wrote is not modular because it intermixes the operation of smoothing with the zero crossing extraction
for example the extractor should not have to be changed if alyssa finds a better way to condition her input signal
help louis by writing a procedure smooth that takes a stream as input and produces a stream in which each element is the average of two successive input stream elements
then use smooth as a component to implement the zero crossing detector in a more modular style
the integral procedure at the end of the preceding section shows how we can use streams to model signal processing systems that contain feedback loops
the feedback loop for the adder shown in figure three point thirty two is modeled by the fact that integral's internal stream int is defined in terms of itself
the interpreter's ability to deal with such an implicit definition depends on the delay that is incorporated into cons stream
without this delay the interpreter could not construct int before evaluating both arguments to cons stream which would require that int already be defined
in general delay is crucial for using streams to model signal processing systems that contain loops
without delay our models would have to be formulated so that the inputs to any signal processing component would be fully evaluated before the output could be produced
this would outlaw loops
unfortunately stream models of systems with loops may require uses of delay beyond the hidden delay supplied by cons stream
for instance figure three point thirty four shows a signal processing system for solving the differential equation dy / dt equal f ( y ) where f is a given function
the figure shows a mapping component which applies f to its input signal linked in a feedback loop to an integrator in a manner very similar to that of the analog computer circuits that are actually used to solve such equations
assuming we are given an initial value y 0 for y we could try to model this system using the procedure
this procedure does not work because in the first line of solve the call to integral requires that the input dy be defined which does not happen until the second line of solve
on the other hand the intent of our definition does make sense because we can in principle begin to generate the y stream without knowing dy
indeed integral and many other stream operations have properties similar to those of cons stream in that we can generate part of the answer given only partial information about the arguments
for integral the first element of the output stream is the specified initial value
thus we can generate the first element of the output stream without evaluating the integrand dy
once we know the first element of y the stream map in the second line of solve can begin working to generate the first element of dy which will produce the next element of y and so on
to take advantage of this idea we will redefine integral to expect the integrand stream to be a delayed argument
integral will force the integrand to be evaluated only when it is required to generate more than the first element of the output stream
now we can implement our solve procedure by delaying the evaluation of dy in the definition of y
in general every caller of integral must now delay the integrand argument
we can demonstrate that the solve procedure works by approximating e 2.718 by computing the value at y equal one of the solution to the differential equation dy / dt equal y with initial condition y ( 0 ) equal one
the integral procedure used above was analogous to the implicit definition of the infinite stream of integers in section three point five point two
alternatively we can give a definition of integral that is more like integers starting from
when used in systems with loops this procedure has the same problem as does our original version of integral
modify the procedure so that it expects the integrand as a delayed argument and hence can be used in the solve procedure shown above
consider the problem of designing a signal processing system to study the homogeneous second order linear differential equation
the output stream modeling y is generated by a network that contains a loop
this is because the value of d2y / dt two depends upon the values of y and dy / dt and both of these are determined by integrating d2y / dt two
the diagram we would like to encode is shown in figure three point thirty five
write a procedure solve 2nd that takes as arguments the constants a b and dt and the initial values y 0 and dy 0 for y and dy / dt and generates the stream of successive values of y
generalize the solve 2nd procedure of exercise three point seventy eight so that it can be used to solve general second order differential equations d two y / dt two equal f
a series rlc circuit consists of a resistor a capacitor and an inductor connected in series as shown in figure three point thirty six
if r l and c are the resistance inductance and capacitance then the relations between voltage ( v ) and current ( i ) for the three components are described by the equations
and the circuit connections dictate the relations
combining these equations shows that the state of the circuit
is described by the pair of differential equations
the signal flow diagram representing this system of differential equations is shown in figure three point thirty seven
write a procedure rlc that takes as arguments the parameters r l and c of the circuit and the time increment dt
in a manner similar to that of the rc procedure of exercise three point seventy three rlc should produce a procedure that takes the initial values of the state variables vc 0 and il 0 and produces a pair of the streams of states vc and il
using rlc generate the pair of streams that models the behavior of a series rlc circuit with r equal one ohm c equal 0.2 farad l equal one henry dt equal 0.1 second and initial values il 0 equal 0 amps and vc 0 equal ten volts
the examples in this section illustrate how the explicit use of delay and force provides great programming flexibility but the same examples also show how this can make our programs more complex
our new integral procedure for instance gives us the power to model systems with loops but we must now remember that integral should be called with a delayed integrand and every procedure that uses integral must be aware of this
in effect we have created two classes of procedures ordinary procedures and procedures that take delayed arguments
in general creating separate classes of procedures forces us to create separate classes of higher order procedures as well
one way to avoid the need for two different classes of procedures is to make all procedures take delayed arguments
we could adopt a model of evaluation in which all arguments to procedures are automatically delayed and arguments are forced only when they are actually needed
this would transform our language to use normal order evaluation which we first described when we introduced the substitution model for evaluation in section one point one point five
converting to normal order evaluation provides a uniform and elegant way to simplify the use of delayed evaluation and this would be a natural strategy to adopt if we were concerned only with stream processing
in section four point two after we have studied the evaluator we will see how to transform our language in just this way
unfortunately including delays in procedure calls wreaks havoc with our ability to design programs that depend on the order of events such as programs that use assignment mutate data or perform input or output
even the single delay in cons stream can cause great confusion as illustrated by exercises three point fifty one and three point fifty two
as far as anyone knows mutability and delayed evaluation do not mix well in programming languages and devising ways to deal with both of these at once is an active area of research
as we saw in section three point one point two one of the major benefits of introducing assignment is that we can increase the modularity of our systems by encapsulating or hiding parts of the state of a large system within local variables
stream models can provide an equivalent modularity without the use of assignment
as an illustration we can reimplement the monte carlo estimation of which we examined in section three point one point two from a stream processing point of view
the key modularity issue was that we wished to hide the internal state of a random number generator from programs that used random numbers
we began with a procedure rand update whose successive values furnished our supply of random numbers and used this to produce a random number generator
in the stream formulation there is no random number generator per se just a stream of random numbers produced by successive calls to rand update
we use this to construct the stream of outcomes of the ces&agrave ro experiment performed on consecutive pairs in the random numbers stream
the cesaro stream is now fed to a monte carlo procedure which produces a stream of estimates of probabilities
the results are then converted into a stream of estimates of
this version of the program does n't need a parameter telling how many trials to perform
better estimates of are obtained by looking farther into the pi stream
there is considerable modularity in this approach because we still can formulate a general monte carlo procedure that can deal with arbitrary experiments
yet there is no assignment or local state
exercise three point six discussed generalizing the random number generator to allow one to reset the random number sequence so as to produce repeatable sequences of random numbers
produce a stream formulation of this same generator that operates on an input stream of requests to generate a new random number or to reset the sequence to a specified value and that produces the desired stream of random numbers
do n't use assignment in your solution
redo exercise three point five on monte carlo integration in terms of streams
the stream version of estimate integral will not have an argument telling how many trials to perform
instead it will produce a stream of estimates based on successively more trials
let us now return to the issues of objects and state that were raised at the beginning of this chapter and examine them in a new light
we introduced assignment and mutable objects to provide a mechanism for modular construction of programs that model systems with state
we constructed computational objects with local state variables and used assignment to modify these variables
we modeled the temporal behavior of the objects in the world by the temporal behavior of the corresponding computational objects
now we have seen that streams provide an alternative way to model objects with local state
we can model a changing quantity such as the local state of some object using a stream that represents the time history of successive states
in essence we represent time explicitly using streams so that we decouple time in our simulated world from the sequence of events that take place during evaluation
indeed because of the presence of delay there may be little relation between simulated time in the model and the order of events during the evaluation
in order to contrast these two approaches to modeling let us reconsider the implementation of a withdrawal processor that monitors the balance in a bank account
in section three point one point three we implemented a simplified version of such a processor
calls to make simplified withdraw produce computational objects each with a local state variable balance that is decremented by successive calls to the object
the object takes an amount as an argument and returns the new balance
we can imagine the user of a bank account typing a sequence of inputs to such an object and observing the sequence of returned values shown on a display screen
alternatively we can model a withdrawal processor as a procedure that takes as input a balance and a stream of amounts to withdraw and produces the stream of successive balances in the account
stream withdraw implements a well defined mathematical function whose output is fully determined by its input
suppose however that the input amount stream is the stream of successive values typed by the user and that the resulting stream of balances is displayed
then from the perspective of the user who is typing values and watching results the stream process has the same behavior as the object created by make simplified withdraw
however with the stream version there is no assignment no local state variable and consequently none of the theoretical difficulties that we encountered in section three point one point three
yet the system has state
this is really remarkable
even though stream withdraw implements a well defined mathematical function whose behavior does not change the user's perception here is one of interacting with a system that has a changing state
one way to resolve this paradox is to realize that it is the user's temporal existence that imposes state on the system
if the user could step back from the interaction and think in terms of streams of balances rather than individual transactions the system would appear stateless
from the point of view of one part of a complex process the other parts appear to change with time
they have hidden time varying local state
if we wish to write programs that model this kind of natural decomposition in our world with structures in our computer we make computational objects that are not functional they must change with time
we model state with local state variables and we model the changes of state with assignments to those variables
by doing this we make the time of execution of a computation model time in the world that we are part of and thus we get objects in our computer
modeling with objects is powerful and intuitive largely because this matches the perception of interacting with a world of which we are part
however as we've seen repeatedly throughout this chapter these models raise thorny problems of constraining the order of events and of synchronizing multiple processes
the possibility of avoiding these problems has stimulated the development of functional programming languages which do not include any provision for assignment or mutable data
in such a language all procedures implement well defined mathematical functions of their arguments whose behavior does not change
the functional approach is extremely attractive for dealing with concurrent systems
on the other hand if we look closely we can see time related problems creeping into functional models as well
one particularly troublesome area arises when we wish to design interactive systems especially ones that model interactions between independent entities
for instance consider once more the implementation a banking system that permits joint bank accounts
in a conventional system using assignment and objects we would model the fact that peter and paul share an account by having both peter and paul send their transaction requests to the same bank account object as we saw in section three point one point three
from the stream point of view where there are no objects per se we have already indicated that a bank account can be modeled as a process that operates on a stream of transaction requests to produce a stream of responses
accordingly we could model the fact that peter and paul have a joint bank account by merging peter's stream of transaction requests with paul's stream of requests and feeding the result to the bank account stream process as shown in figure three point thirty eight
the trouble with this formulation is in the notion of merge
it will not do to merge the two streams by simply taking alternately one request from peter and one request from paul
suppose paul accesses the account only very rarely
we could hardly force peter to wait for paul to access the account before he could issue a second transaction
however such a merge is implemented it must interleave the two transaction streams in some way that is constrained by real time as perceived by peter and paul in the sense that if peter and paul meet they can agree that certain transactions were processed before the meeting and other transactions were processed after the meeting
this is precisely the same constraint that we had to deal with in section three point four point one where we found the need to introduce explicit synchronization to ensure a correct order of events in concurrent processing of objects with state
thus in an attempt to support the functional style the need to merge inputs from different agents reintroduces the same problems that the functional style was meant to eliminate
we began this chapter with the goal of building computational models whose structure matches our perception of the real world we are trying to model
we can model the world as a collection of separate time bound interacting objects with state or we can model the world as a single timeless stateless unity
each view has powerful advantages but neither view alone is completely satisfactory
a grand unification has yet to emerge
